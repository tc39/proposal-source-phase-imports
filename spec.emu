<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Import Source Reflection
stage: 2
contributors: Luca Casonato, Guy Bedford, Nicol√≤ Ribaudo
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type" number="6">
  <h1>ECMAScript Data Types and Values</h1>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>
    <emu-clause id="sec-object-type">
      <h1>The <dfn variants="is an Object,is not an Object">Object Type</dfn></h1>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>Well-Known Intrinsic Objects</h1>
        <p>Well-known intrinsics are built-in objects that are explicitly referenced by the algorithms of this specification and which usually have realm-specific identities. Unless otherwise specified each intrinsic object actually corresponds to a set of similar objects, one per realm.</p>
        <p>Within this specification a reference such as %name% means the intrinsic object, associated with the current realm, corresponding to the name. A reference such as %name.a.b% means, as if the *"b"* property of the value of the *"a"* property of the intrinsic object %name% was accessed prior to any ECMAScript code being evaluated. Determination of the current realm and its intrinsics is described in <emu-xref href="#sec-execution-contexts"></emu-xref>. The well-known intrinsics are listed in <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>.</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="Well-Known Intrinsic Objects" oldids="table-7">
          <table>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in async iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                The `AggregateError` constructor (<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                The Array constructor (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                The ArrayBuffer constructor (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Array iterator objects (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of async-from-sync iterator objects (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async function objects (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async iterator objects (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in async iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                The `Atomics` object (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                The BigInt constructor (<emu-xref href="#sec-bigint-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                The BigInt64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                The BigUint64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                The Boolean constructor (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                The DataView constructor (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                The Date constructor (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                The `decodeURI` function (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                The `decodeURIComponent` function (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                The `encodeURI` function (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                The `encodeURIComponent` function (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                The Error constructor (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                The `eval` function (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                The EvalError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                The FinalizationRegistry constructor (<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                The Float32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                The Float64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of For-In iterator objects (<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                The Function constructor (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of Generators (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                The Int8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                The Int16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                The Int32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                The `isFinite` function (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                The `isNaN` function (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                The `JSON` object (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                The Map constructor (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Map iterator objects (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                The `Math` object (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                <ins>%AbstractModuleSourcePrototype%</ins>
              </td>
              <td>
              </td>
              <td>
                <ins>An object that all module source objects indirectly inherit from (<emu-xref href="#sec-modulesource-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>%ModuleSource%</ins>
              </td>
              <td>
              </td>
              <td>
                <ins>The ModuleSource constructor (<emu-xref href="#sec-modulesource-constructor"></emu-xref>)</ins>
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                The Number constructor (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                The Object constructor (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                The `parseFloat` function (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                The `parseInt` function (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                The Promise constructor (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                The Proxy constructor (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                The RangeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                The ReferenceError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                The `Reflect` object (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                The RegExp constructor (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of RegExp String Iterator objects (<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                The Set constructor (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Set iterator objects (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                The SharedArrayBuffer constructor (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                The String constructor (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of String iterator objects (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                The Symbol constructor (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                The SyntaxError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                A function object that unconditionally throws a new instance of %TypeError%
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                The super class of all typed Array constructors (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                The TypeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                The Uint8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                The Uint8ClampedArray constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                The Uint16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                The Uint32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                The URIError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                The WeakMap constructor (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                The WeakRef constructor (<emu-xref href="#sec-weak-ref-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                The WeakSet constructor (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Additional entries in <emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-import-calls" number="3.10">
    <h1>Import Calls</h1>

    <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>

      <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
      <emu-alg>
        1. <del>Let _referrer_ be GetActiveScriptOrModule().</del>
        1. <del>If _referrer_ is *null*, set _referrer_ to the current Realm Record.</del>
        1. <del>Let _argRef_ be ? Evaluation of |AssignmentExpression|.</del>
        1. <del>Let _specifier_ be ? GetValue(_argRef_).</del>
        1. <del>Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).</del>
        1. <del>Let _specifierString_ be Completion(ToString(_specifier_)).</del>
        1. <del>IfAbruptRejectPromise(_specifierString_, _promiseCapability_).</del>
        1. <del>Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).</del>
        1. <del>Return _promiseCapability_.[[Promise]].</del>
        1. <ins>Let _specifierRef_ be the result of evaluating |AssignmentExpression|.</ins>
        1. <ins>Let _specifier_ be ? GetValue(_specifierRef_).</ins>
        1. <ins>Return EvaluateImportCall(_specifier_, *undefined*).</ins>
      </emu-alg>

      <emu-grammar><ins>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `)`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _specifierRef_ be the result of evaluating the first |AssignmentExpression|.</ins>
        1. <ins>Let _specifier_ be ? GetValue(_specifierRef_).</ins>
        1. <ins>Let _optionsRef_ be the result of evaluating the second |AssignmentExpression|.</ins>
        1. <ins>Let _options_ be ? GetValue(_optionsRef_).</ins>
        1. <ins>Return EvaluateImportCall(_specifier_, _options_).</ins>
      </emu-alg>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1><ins>EvaluateImportCall ( _specifier_ , _options_ )</ins></h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _sourcePhase_ be *false*.
          1. If _options_ is not *undefined*, then
            1. If Type(_options_) is not Object,
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _phaseOption_ be Get(_options_, *"phase"*).
            1. IfAbruptRejectPromise(_phaseOption_, _promiseCapability_).
            1. If _phaseOption_ is not *undefined*,
              1. If Type(_phaseOption_) is not *"source"*, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                1. Return _promiseCapability_.[[Promise]].
              1. Set _sourcePhase_ to *true*.
          1. Let _state_ be the DynamicImportState Record { [[PromiseCapability]]: _promiseCapability_, [[SourcePhase]]: _sourcePhase_ }.
          1. Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _state_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <p><ins>A <dfn id="dynamicimportstate-record" variants="DynamicImportState Records">DynamicImportState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each DynamicImportState Record has the fields defined in <emu-xref href="#table-dynamicimportstate-record-fields"></emu-xref>:</ins></p>
      <emu-table id="table-dynamicimportstate-record-fields" caption="DynamicImportState Record Fields">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              <ins>[[PromiseCapability]]</ins>
            </td>
            <td>
              <ins>a PromiseCapability Record</ins>
            </td>
            <td>
              <ins>The promise to resolve when the dynamic import finishes.</ins>
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[SourcePhase]]</ins>
            </td>
            <td>
              <ins>a Boolean</ins>
            </td>
            <td>
              <ins>It is true if the <code>phase: "source"</code> option was specified.</ins>
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            <del>_promiseCapability_: a PromiseCapability Record,</del>
            <ins>_state_: a DynamicImportState Record,</ins>
            _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate.</dd>
        </dl>
        <emu-alg>
          1. <ins>Let _promiseCapability_ be _state_.[[PromiseCapability]].</ins>
          1. If _moduleCompletion_ is an abrupt completion, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).
            1. Return ~unused~.
          1. Let _module_ be _moduleCompletion_.[[Value]].
          1. <ins>If _state_.[[SourcePhase]] is *true*, then</ins>
            1. <ins>Let _moduleSourceObject_ be _module_.[[ModuleSourceObject]].</ins>
            1. <ins>If _moduleSourceObject_ is *null*, then</ins>
              1. <ins>Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).</ins>
              1. <ins>Return ~unused~.</ins>
            1. <ins>Note: _moduleSourceObject_.[[Prototype]].[[Prototype]] should be %AbstractModuleSourcePrototype%.</ins>
            1. <ins>Assert: _moduleSourceObject_ has a [[HostSourceData]] internal slot.</ins>
            1. <ins>Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _moduleSourceObject_ &raquo;).</ins>
            1. <ins>Return ~unused~.</ins>
          1. Let _loadPromise_ be _module_.LoadRequestedModules().
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _reason_ &raquo;).
            1. Return ~unused~.
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, &laquo; &raquo;).
          1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:
            1. Let _link_ be Completion(_module_.Link()).
            1. If _link_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _link_.[[Value]] &raquo;).
              1. Return ~unused~.
            1. Let _evaluatePromise_ be _module_.Evaluate().
            1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:
              1. Let _namespace_ be GetModuleNamespace(_module_).
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_ &raquo;).
              1. Return ~unused~.
            1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, *""*, 0, &laquo; &raquo;).
            1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
          1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, *""*, 0, &laquo; &raquo;).
          1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-modulerequest-record">
        <h1><ins>ModuleRequest Records</ins></h1>

        <p>A <dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> represents the request to import a module up to a given phase. It consists of the following fields:</p>
        <emu-table id="table-modulerequest-record-fields" caption="ModuleRequest Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Specifier]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The module specifier
                </td>
              </tr>
              <tr>
                <td>
                  [[Phase]]
                </td>
                <td>
                  ~source~ or ~evaluation~
                </td>
                <td>
                  The target import phase
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type="editor">In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo" number="3">
        <h1>
          Static Semantics: ModuleRequests ( ): a List of <del>Strings</del><ins>ModuleRequest Records</ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let <del>_moduleNames_</del><ins>_requests_</ins> be ModuleRequests of |ModuleItemList|.
          1. Let <del>_additionalNames_</del><ins>_additionalRequests_</ins> be ModuleRequests of |ModuleItem|.
          1. <del>For each String _name_ of _additionalNames_, do</del>
          1. <ins>For each ModuleRequest Record _mr_ of _additionalRequests_, do</ins>
            1. <ins>Let _found_ be *false*.</ins>
            1. <ins>For each ModuleRequest Record _mr2_ of _requests_, do</ins>
              1. <ins>If _mr_.[[Specifer]] is _mr2_.[[Specifer]], then</ins>
                1. <ins>Assert: _found_ is *false*.</ins>
                1. <ins>Set _found_ to *true*.</ins>
                1. <ins>If _mr2_.[[Phase]] is ~source~ and _mr_.[[Phase]] is ~evaluation~, set _mr2_.[[Phase]] to ~evaluation~.</ins>
            1. <del>If _moduleNames_ does not contain _name_, then</del>
            1. <ins>If _found_ is *false*, then</ins>
              1. Append <del>_name_</del><ins>_mr_</ins> to <del>_moduleNames_</del><ins>_requests_</ins>.
          1. Return <del>_moduleNames_</del><ins>_requests_</ins>.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>
          ImportDeclaration : `import` ImportClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~evaluation~ }.</ins>
        </emu-alg>
        <emu-grammar><ins>ImportDeclaration : `import` `source` ImportedBinding FromClause `;`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~source~ }.</ins>
        </emu-alg>
        <emu-grammar><del>ModuleSpecifier : StringLiteral</del></emu-grammar>
        <emu-alg>
          1. <del>Return a List whose sole element is the SV of |StringLiteral|.</del>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~evaluation~ }.</ins>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulesource-record">
        <h1><ins>ModuleSource Records</ins></h1>

        <p>A <dfn id="modulesource-record" variants="ModuleSource Records">ModuleSource Record</dfn> represents the request to import a module up to a given phase. It consists of the following fields:</p>
        <emu-table id="table-modulesource-record-fields" caption="ModuleSource Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[SourceClassName]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The unique source class name string used to represent this module source. Source Text Module Records are usually represented by the *"ModuleSource"* class.
                </td>
              </tr>
              <tr>
                <td>
                  [[HostDefined]]
                </td>
                <td>
                  anything (default value is *undefined*)
                </td>
                <td>
                  Field reserved for use by host environments to associate additional information with module sources.
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type="editor">In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>
        <p>A <dfn variants="Module Records">Module Record</dfn> encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.</p>
        <p>For specification purposes Module Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named Cyclic Module Record and its concrete subclass named Source Text Module Record. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.</p>
        <p>Module Record defines the fields listed in <emu-xref href="#table-module-record-fields"></emu-xref>. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>. All Module definition subclasses must provide concrete implementations of these abstract methods.</p>
        <emu-table id="table-module-record-fields" caption="Module Record Fields" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                a Realm Record
              </td>
              <td>
                The Realm within which this module was created.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                a Module Environment Record or ~empty~
              </td>
              <td>
                The Environment Record containing the top level bindings for this module. This field is set when the module is linked.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                an Object or ~empty~
              </td>
              <td>
                The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>) if one has been created for this module.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ModuleSourceObject]]</ins>
              </td>
              <td>
                <ins>an Object or *null* (defaults to *null*)</ins>
              </td>
              <td>
                <ins>The ModuleSource Object corresponding to this source Module Record's source phase (<emu-xref href="#sec-module-source-objects"></emu-xref>), if it has been requested.</ins>
                <ins>This object must have a [[ModuleSourceRecord]] internal slot and %AbstractModuleSourcePrototype% at the root of its prototype chain.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is *undefined*)
              </td>
              <td>
                Field reserved for use by host environments that need to associate additional information with a module.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>

        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~unlinked~. Transitions to ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this non-negative number records the point at which the module was first visited during the depth-first traversal of the dependency graph.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of <del>Strings</del><ins>ModuleRequest Records</ins>
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module, <ins>along with their associated phase (~source~ or ~evaluation~)</ins>. The List is in source text occurrence order.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is equal to the [[DFSIndex]] of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is either itself asynchronous or has an asynchronous dependency. Note: The order in which this field is set is used to order queued executions, see <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything,
            ): a Promise object
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>optional _referrer_: a Cyclic Module Record,</ins>
                <ins>optional _specifier_: a String,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. <del>For each String _required_ of _module_.[[RequestedModules]], do</del>
                1. <ins>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</ins>
                  1. <ins>Let _specifier_ be _required_.[[Specifier]].</ins>
                  1. If _module_.[[LoadedModules]] contains a Record whose [[Specifier]] is <del>_required_</del><ins>_specifier_</ins>, then
                    1. Let _record_ be that Record.
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]]).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, <del>_required_</del><ins>_specifier_</ins>, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] ‚â• 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, ¬´ *undefined* ¬ª).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
          <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>

          <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
            <h1>
              InnerModuleLinking (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Link().
                1. Return _index_.
              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Set _module_.[[Status]] to ~linking~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. For each <del>String</del><ins>ModuleRequest</ins> _required_ of _module_.[[RequestedModules]], do
                1. <ins>If _required_.[[Phase]] is ~evaluation~, then</ins>
                  1. Let _requiredModule_ be GetImportedModule(_module_, _required_<ins>.[[Specifier]]</ins>).
                  1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~linking~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ‚â§ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to ~linked~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
        <emu-clause id="sec-moduleevaluation" type="concrete method">
          <h1>Evaluate ( ): a Promise</h1>

          <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
            <h1>
              InnerModuleEvaluation (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in InnerModuleLinking.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Let _promise_ be ! _module_.Evaluate().
                1. Assert: _promise_.[[PromiseState]] is not ~pending~.
                1. If _promise_.[[PromiseState]] is ~rejected~, then
                  1. Return ThrowCompletion(_promise_.[[PromiseResult]]).
                1. Return _index_.
              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then
                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                1. Otherwise, return ? _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is ~evaluating~, return _index_.
              1. Assert: _module_.[[Status]] is ~linked~.
              1. Set _module_.[[Status]] to ~evaluating~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _module_.[[PendingAsyncDependencies]] to 0.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. <del>For each String _required_ of _module_.[[RequestedModules]], do</del>
              1. <ins>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</ins>
                1. Let _requiredModule_ be GetImportedModule(_module_, _required_<ins>.[[Specifier]]</ins>).
                1. <ins>If _requiredModule_.[[Phase]] is ~evaluation~, then</ins>
                  1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~evaluating~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                    1. Else,
                      1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                      1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                      1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                    1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then
                      1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.
                      1. Append _module_ to _requiredModule_.[[AsyncParentModules]].
              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then
                1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.
                1. Set _module_.[[AsyncEvaluation]] to *true*.
                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.)
                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).
              1. Else,
                1. Perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ‚â§ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.
                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                  1. Set _requiredModule_.[[CycleRoot]] to _module_.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-resolveexport" type="concrete method" number="3">
          <h1>
            ResolveExport (
              _exportName_: a String,
              optional _resolveSet_: a List of Records with fields [[Module]] (a Module Record) and [[ExportName]] (a String),
            ): a ResolvedBinding Record, *null*, or ~ambiguous~
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>

            <dt>description</dt>
            <dd>
              <p>ResolveExport attempts to resolve an imported binding to the actual defining module and local binding name. The defining module may be the module represented by the Module Record this method was invoked on or some other module that is imported by that module. The parameter _resolveSet_ is used to detect unresolved circular import/export paths. If a pair consisting of specific Module Record and _exportName_ is reached that is already in _resolveSet_, an import circularity has been encountered. Before recursively calling ResolveExport, a pair consisting of _module_ and _exportName_ is added to _resolveSet_.</p>
              <p>If a defining module is found, a ResolvedBinding Record { [[Module]], [[BindingName]] } is returned. This record identifies the resolved binding of the originally requested export, unless this is the export of a namespace with no local binding. In this case, [[BindingName]] will be set to ~namespace~. If no definition was found or the request is found to be circular, *null* is returned. If the request is found to be ambiguous, ~ambiguous~ is returned.</p>
            </dd>
          </dl>

          <emu-alg>
            1. Assert: _module_.[[Status]] is not ~new~.
            1. If _resolveSet_ is not present, set _resolveSet_ to a new empty List.
            1. For each Record { [[Module]], [[ExportName]] } _r_ of _resolveSet_, do
              1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then
                1. Assert: This is a circular import request.
                1. Return *null*.
            1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.
            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do
              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
                1. Assert: _module_ provides the direct binding for this export.
                1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
                1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]<ins>.[[Specifier]]</ins>).
                1. If _e_.[[ImportName]] is ~all~, then
                  1. Assert: _module_ does not provide the direct binding for this export.
                  1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }.
                1. Else,
                  1. Assert: _module_ imports a specific binding for this export.
                  1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).
            1. If SameValue(_exportName_, *"default"*) is *true*, then
              1. Assert: A `default` export was not explicitly defined by this module.
              1. Return *null*.
              1. NOTE: A `default` export cannot be provided by an `export * from "mod"` declaration.
            1. Let _starResolution_ be *null*.
            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]<ins>.[[Specifier]]</ins>).
              1. Let _resolution_ be _importedModule_.ResolveExport(_exportName_, _resolveSet_).
              1. If _resolution_ is ~ambiguous~, return ~ambiguous~.
              1. If _resolution_ is not *null*, then
                1. Assert: _resolution_ is a ResolvedBinding Record.
                1. If _starResolution_ is *null*, set _starResolution_ to _resolution_.
                1. Else,
                  1. Assert: There is more than one `*` import that includes the requested name.
                  1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record, return ~ambiguous~.
                  1. If _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]] and either _resolution_.[[BindingName]] or _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.
                  1. If _resolution_.[[BindingName]] is a String, _starResolution_.[[BindingName]] is a String, and SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return ~ambiguous~.
            1. Return _starResolution_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]<ins>.[[Specifier]]</ins>).
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. Else,
                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _declaredVarNames_ does not contain _dn_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" number="8">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _specifier_: a String,
            _state_: a GraphLoadingState Record or a DynamicImportState Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _state_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_state_, <ins>_referrer_, _specifier_,</ins> _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_state_, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-imports">
    <h1>Imports</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ImportDeclaration :
        `import` ImportClause FromClause `;`
        `import` ModuleSpecifier `;`
        <ins>`import` `source` ImportedBinding FromClause `;`</ins>

      ImportClause :
        ImportedDefaultBinding
        NameSpaceImport
        NamedImports
        ImportedDefaultBinding `,` NameSpaceImport
        ImportedDefaultBinding `,` NamedImports
  
      ImportedDefaultBinding :
        ImportedBinding
  
      NameSpaceImport :
        `*` `as` ImportedBinding
  
      NamedImports :
        `{` `}`
        `{` ImportsList `}`
        `{` ImportsList `,` `}`
  
      FromClause :
        `from` ModuleSpecifier
  
      ImportsList :
        ImportSpecifier
        ImportsList `,` ImportSpecifier
  
      ImportSpecifier :
        ImportedBinding
        ModuleExportName `as` ImportedBinding
  
      ModuleSpecifier :
        StringLiteral
  
      ImportedBinding :
        BindingIdentifier[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="syntax-directed operation">
      <h1>Static Semantics: ImportEntries ( ): a List of ImportEntry Records</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ImportEntries of |ModuleItemList|.
        1. Let _entries2_ be ImportEntries of |ModuleItem|.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ExportDeclaration
          StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
        1. Return ImportEntriesForModule of |ImportClause| with argument _module_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar><ins>ImportDeclaration : `import` `source` ImportedBinding FromClause `;`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _module_ be SV of |FromClause|.</ins>
        1. <ins>Return ImportEntriesForModule of |ImportClause| with arguments _module_ and ~source~.</ins>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo">
      <h1>
        Static Semantics: ImportEntriesForModule (
          _module_: a String,
          <ins>_phase_: ~source~ or ~evaluation~,</ins>
        ): a List of ImportEntry Records
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with arguments _module_ <ins>and _phase_</ins>.
        1. Let _entries2_ be ImportEntriesForModule of |NameSpaceImport| with arguments _module_ <ins>and _phase_</ins>.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with arguments _module_ <ins>and _phase_</ins>.
        1. Let _entries2_ be ImportEntriesForModule of |NamedImports| with arguments _module_ <ins>and _phase_</ins>.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
      <emu-alg>
        1. <ins>Assert: _phase_ is ~evaluation~.</ins>
        1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.
        1. Let _defaultEntry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, <ins>[[Phase]]: _phase_,</ins> [[ImportName]]: *"default"*, [[LocalName]]: _localName_ }.
        1. Return ¬´ _defaultEntry_ ¬ª.
      </emu-alg>
      <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. Let _localName_ be the StringValue of |ImportedBinding|.
        1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, <ins>[[Phase]]: _phase_,</ins> [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ }.
        1. Return ¬´ _entry_ ¬ª.
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. <ins>Assert: _phase_ is ~evaluation~.</ins>
        1. Let _specs1_ be the ImportEntriesForModule of |ImportsList| with arguments _module_ <ins>and _phase_</ins>.
        1. Let _specs2_ be the ImportEntriesForModule of |ImportSpecifier| with arguments _module_ <ins>and _phase_</ins>.
        1. Return the list-concatenation of _specs1_ and _specs2_.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
      <emu-alg>
        1. <ins>Assert: _phase_ is ~evaluation~.</ins>
        1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.
        1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, <ins>[[Phase]]: _phase_,</ins> [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.
        1. Return ¬´ _entry_ ¬ª.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. <ins>Assert: _phase_ is ~evaluation~.</ins>
        1. Let _importName_ be the StringValue of |ModuleExportName|.
        1. Let _localName_ be the StringValue of |ImportedBinding|.
        1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, <ins>[[Phase]]: _phase_,</ins> [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.
        1. Return ¬´ _entry_ ¬ª.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exports">
    <h1>Exports</h1>

    <emu-clause id="sec-static-semantics-exportentries" type="sdo" number="4">
      <h1>Static Semantics: ExportEntries ( ): a List of ExportEntry Records</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ExportEntries of |ModuleItemList|.
        1. Let _entries2_ be ExportEntries of |ModuleItem|.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Let _module_ be <del>the sole element of ModuleRequests</del><ins>SV</ins> of |FromClause|.
        1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
      <emu-alg>
        1. Return ExportEntriesForModule of |NamedExports| with argument *null*.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. Let _entries_ be a new empty List.
        1. Let _names_ be the BoundNames of |VariableStatement|.
        1. For each element _name_ of _names_, do
          1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
        1. Return _entries_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. Let _entries_ be a new empty List.
        1. Let _names_ be the BoundNames of |Declaration|.
        1. For each element _name_ of _names_, do
          1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
        1. Return _entries_.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. Let _names_ be BoundNames of |HoistableDeclaration|.
        1. Let _localName_ be the sole element of _names_.
        1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. Let _names_ be BoundNames of |ClassDeclaration|.
        1. Let _localName_ be the sole element of _names_.
        1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* }.
        1. Return ¬´ _entry_ ¬ª.
      </emu-alg>
      <emu-note>
        <p>*"\*default\*"* is used within this specification as a synthetic name for anonymous default export values. See <emu-xref href="#note-star-default-star">this note</emu-xref> for more details.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-global-object" number=19>
  <h1>The Global Object</h1>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>Constructor Properties of the Global Object</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-module-source">
      <h1>ModuleSource ( . . . )</h1>
      <p>See <emu-xref href="#sec-modulesource-constructor"></emu-xref>.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection" number=28>
  <h1>Reflection</h1>
  <emu-clause id="sec-module-source-objects">
    <h1><ins>Module Source Objects</ins></h1>
    <p>Module Source Objects represent modules in their source import phase, which are not linked, instantiated or executed.</p>
    <p>All Module Source Objects, including ModuleSource and host-defined types, have a prototype of %AbstractModuleSourcePrototype% and provide a [[ModuleSourceRecord]] internal slot.</p>
    <p>The ModuleSource Object represents the standard representation of the source of a Source Text Module Module record. Hosts may define their own Module Source Objects for other module record types.</p>

    <emu-clause id="sec-%abstractmodulesourceprototype%-intrinsic-object">
      <h1>The %AbstractModuleSourcePrototype% Object</h1>
      <p>The <dfn>%AbstractModuleSourcePrototype%</dfn> object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-get-%abstractmodulesourceprototype%.@@tostringtag">
        <h1>get %AbstractModuleSourcePrototype% [ @@toStringTag ]</h1>
        <p>%AbstractModuleSourcePrototype%`[@@toStringTag]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, return *undefined*.
          1. If _O_ does not have a [[ModuleSourceRecord]] internal slot, return *undefined*.
          1. Let _name_ be _O_.[[ModuleSourceRecord]].[[SourceClassName]]
          1. Assert: _name_ is a String.
          1. Return _name_.
        </emu-alg>
        <p>This property has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The initial value of the *"name"* property of this function is *"get [Symbol.toStringTag]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-modulesource-constructor">
      <h1>The ModuleSource Constructor</h1>
      <p>The ModuleSource Object represents the source phase of a SourceTextModuleRecord.</p>

      <p>The ModuleSource constructor:</p>
      <ul>
        <li>is <dfn>%ModuleSource%</dfn>.</li>
        <li>is the initial value of the *"ModuleSource"* property of the global object.</li>
        <li>has a [[Prototype]] internal slot whose value is %AbstractModuleSourcePrototype%.</li>
        <li>does not have a [[ModuleSourceRecord]] internal slot.
      </ul>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-modulesource-prototype-object">
      <h1>Properties of the ModuleSource Prototype Object</h1>
      <p>The <dfn>ModuleSource prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%ModuleSource.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %AbstractModuleSourcePrototype%.</li>
        <li>is not a ModuleSource instance or a %AbstractModuleSourcePrototype% and does not have a [[ModuleSourceRecord]] internal slot.
      </ul>
    </emu-clause>

    <emu-clause id="sec-properties-of-modulesource-instances">
      <h1>Properties of ModuleSource Instances</h1>
      <p>ModuleSource instances are ordinary objects that inherit properties from the ModuleSource Prototype.</p>
      <p>ModuleSource instances have a [[ModuleSourceRecord]] internal slot containing their associated ModuleSource Record whose [[SourceClassName]] field is *"ModuleSource"*.</p>

      <emu-note>
        <p>Only SourceTextModuleRecord modules may be represented in their source phase by a ModuleSource instance and the *"ModuleSource"* string value for [[SourceClassName]].</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createmodulesource" type="abstract operation">
      <h1>
        CreateModuleSource (
          _sourceClassName_: a String,
          _hostDefined_: anything,
        ): a ModuleSource Instance
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>Create a new ModuleSource with the provided _sourceClassName_ name and _hostDefined_ data.</dd>
      </dl>
      <emu-alg>
        1. Let _moduleSourceRecord_ be the ModuleSource Record { [[SourceClassName]]: _sourceClassName_, [[HostDefined]]: _hostDefined_ }.
        1. Let _moduleSource_ be OrdinaryObjectCreate(%ModuleSource.prototype%).
        1. Set _moduleSource_.[[ModuleSourceRecord]] to _moduleSourceRecord_.
        1. Return _moduleSource_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>Host-defined Fields</h1>
    <p>[[HostDefined]] on Realm Records: See <emu-xref href="#table-realm-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on Script Records: See <emu-xref href="#table-script-records"></emu-xref>.</p>
    <p>[[HostDefined]] on Module Records: See <emu-xref href="#table-module-record-fields"></emu-xref>.</p>
    <p><ins>[[HostDefined]] on ModuleSource Records: See <emu-xref href="#table-modulesource-record-fields"></emu-xref>.</ins></p>
    <p>[[HostDefined]] on JobCallback Records: See <emu-xref href="#table-jobcallback-records"></emu-xref>.</p>
    <p>[[HostSynchronizesWith]] on Candidate Executions: See <emu-xref href="#table-candidate-execution-records"></emu-xref>.</p>
    <p>[[IsHTMLDDA]]: See <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref>.</p>
  </emu-annex>
</emu-annex>

<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Source Phase Imports
stage: 3
contributors: Luca Casonato, Guy Bedford, Nicol√≤ Ribaudo
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values" aoid="Type">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript Language Types</h1>
    <emu-clause id="sec-object-type">
      <h1>Object Type</h1>
      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>Well-Known Intrinsic Objects</h1>
        <p>Well-known intrinsics are built-in objects that are explicitly referenced by the algorithms of this specification and which usually have realm-specific identities. Unless otherwise specified each intrinsic object actually corresponds to a set of similar objects, one per realm.</p>
        <p>Within this specification a reference such as %name% means the intrinsic object, associated with the current realm, corresponding to the name. A reference such as %name.a.b% means, as if the *"b"* property of the value of the *"a"* property of the intrinsic object %name% was accessed prior to any ECMAScript code being evaluated. Determination of the current realm and its intrinsics is described in <emu-xref href="#sec-execution-contexts"></emu-xref>. The well-known intrinsics are listed in <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>.</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="Well-Known Intrinsic Objects" oldids="table-7">
          <table>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
            <tr>
              <td>
                %AbstractModuleSource%
              </td>
              <td>
              </td>
              <td>
                The %AbstractModuleSource% constructor (<emu-xref href="#sec-%abstractmodulesource%-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                The `AggregateError` constructor (<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                The Array constructor (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                The ArrayBuffer constructor (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Array iterator objects (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of async-from-sync iterator objects (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async function objects (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of async generator function objects (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of async generator objects (<emu-xref href="#sec-asyncgenerator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in async iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                The `Atomics` object (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                The BigInt constructor (<emu-xref href="#sec-bigint-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                The BigInt64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                The BigUint64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                The Boolean constructor (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                The DataView constructor (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                The Date constructor (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                The `decodeURI` function (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                The `decodeURIComponent` function (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                The `encodeURI` function (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                The `encodeURIComponent` function (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                The Error constructor (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                The `eval` function (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                The EvalError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                The FinalizationRegistry constructor (<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                The Float32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                The Float64Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of For-In iterator objects (<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                The Function constructor (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                The constructor of generator function objects (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of generator objects (<emu-xref href="#sec-generator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                The Int8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                The Int16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                The Int32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                The `isFinite` function (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                The `isNaN` function (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                An object that all standard built-in iterator objects indirectly inherit from
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                The `JSON` object (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                The Map constructor (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Map iterator objects (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                The `Math` object (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                The Number constructor (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                The Object constructor (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                The `parseFloat` function (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                The `parseInt` function (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                The Promise constructor (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                The Proxy constructor (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                The RangeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                The ReferenceError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                The `Reflect` object (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                The RegExp constructor (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of RegExp String Iterator objects (<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                The Set constructor (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of Set iterator objects (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                The SharedArrayBuffer constructor (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                The String constructor (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                The prototype of String iterator objects (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                The Symbol constructor (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                The SyntaxError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                A function object that unconditionally throws a new instance of %TypeError%
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                The super class of all typed Array constructors (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                The TypeError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                The Uint8Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                The Uint8ClampedArray constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                The Uint16Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                The Uint32Array constructor (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                The URIError constructor (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                The WeakMap constructor (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                The WeakRef constructor (<emu-xref href="#sec-weak-ref-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                The WeakSet constructor (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Additional entries in <emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-left-hand-side-expressions" number="3">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `)`
        <ins>`import` `.` `source` `(` AssignmentExpression[+In, ?Yield, ?Await] `)`</ins>
    </emu-grammar>

    <emu-clause id="sec-import-calls" number="10">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `)`</emu-grammar>
        <emu-alg>
          1. <del>Let _referrer_ be GetActiveScriptOrModule().</del>
          1. <del>If _referrer_ is *null*, set _referrer_ to the current Realm Record.</del>
          1. <del>Let _argRef_ be ? Evaluation of |AssignmentExpression|.</del>
          1. <del>Let _specifier_ be ? GetValue(_argRef_).</del>
          1. <del>Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).</del>
          1. <del>Let _specifierString_ be Completion(ToString(_specifier_)).</del>
          1. <del>IfAbruptRejectPromise(_specifierString_, _promiseCapability_).</del>
          1. <del>Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).</del>
          1. <del>Return _promiseCapability_.[[Promise]].</del>
          1. <ins>Return ? EvaluateImportCall(|AssignmentExpression|, ~evaluation~).</ins>
        </emu-alg>

        <emu-grammar><ins>ImportCall : `import` `.` `source` `(` AssignmentExpression[+In, ?Yield, ?Await] `)`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Return ? EvaluateImportCall(|AssignmentExpression|, ~source~).</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          <ins>
            EvaluateImportCall (
              _specifierExpression_: a Parse Node,
              _phase_: ~source~ or ~evaluation~
            ): either a normal completion containing a Promise or a throw completion
          </ins>
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _specifierRef_ be ? Evaluation of evaluating _specifierExpression_.
          1. Let _specifier_ be ? GetValue(_specifierRef_).
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _moduleRequest_ be a new ModuleRequest Record { [[Specifier]]: _specifierString_, [[Phase]]: _phase_ }.
          1. Perform HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>

        <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
          <h1>
            ContinueDynamicImport (
              _promiseCapability_: a PromiseCapability Record,
              <ins>_phase_: ~source~ or ~evaluation~,</ins>
              _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate.</dd>
          </dl>
          <emu-alg>
            1. If _moduleCompletion_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).
              1. Return ~unused~.
            1. Let _module_ be _moduleCompletion_.[[Value]].
            1. <ins>If _phase_ is ~source~, then</ins>
              1. <ins>Let _moduleSourceCompletion_ be Completion(_module_.GetModuleSource()).</ins>
              1. <ins>If _moduleSourceCompletion_ is an abrupt completion, then</ins>
                1. <ins>Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleSourceCompletion_.[[Value]] &raquo;).</ins>
              1. <ins>Else,</ins>
                1. <ins>Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _moduleSourceCompletion_.[[Value]] &raquo;).</ins>
              1. <ins>Return ~unused~.</ins>
            1. Let _loadPromise_ be _module_.LoadRequestedModules().
            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _reason_ &raquo;).
              1. Return ~unused~.
            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, &laquo; &raquo;).
            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:
              1. Let _link_ be Completion(_module_.Link()).
              1. If _link_ is an abrupt completion, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _link_.[[Value]] &raquo;).
                1. Return ~unused~.
              1. Let _evaluatePromise_ be _module_.Evaluate().
              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:
                1. Let _namespace_ be GetModuleNamespace(_module_).
                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_ &raquo;).
                1. Return ~unused~.
              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, *""*, 0, &laquo; &raquo;).
              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, *""*, 0, &laquo; &raquo;).
            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-modulerequest-record">
        <h1><ins>ModuleRequest Records</ins></h1>

        <p>A <dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> represents a request to import a module up to a given phase. It consists of the following fields:</p>
        <emu-table id="table-modulerequest-record-fields" caption="ModuleRequest Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Specifier]]
                </td>
                <td>
                  a String
                </td>
                <td>
                  The module specifier
                </td>
              </tr>
              <tr>
                <td>
                  [[Phase]]
                </td>
                <td>
                  ~source~ or ~evaluation~
                </td>
                <td>
                  The target import phase
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type="editor">In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo" number="3">
        <h1>
          Static Semantics: ModuleRequests ( ): a List of <del>Strings</del><ins>ModuleRequest Records</ins>
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let <del>_moduleNames_</del><ins>_requests_</ins> be ModuleRequests of |ModuleItemList|.
          1. Let <del>_additionalNames_</del><ins>_additionalRequests_</ins> be ModuleRequests of |ModuleItem|.
          1. <del>For each String _name_ of _additionalNames_, do</del>
          1. <ins>For each ModuleRequest Record _mr_ of _additionalRequests_, do</ins>
            1. <ins>Let _found_ be *false*.</ins>
            1. <ins>For each ModuleRequest Record _mr2_ of _requests_, do</ins>
              1. <ins>If _mr_.[[Specifer]] is _mr2_.[[Specifer]] and _mr_.[[Phase]] is _mr2_.[[Phase]], then</ins>
                1. <ins>Assert: _found_ is *false*.</ins>
                1. <ins>Set _found_ to *true*.</ins>
            1. <del>If _moduleNames_ does not contain _name_, then</del>
            1. <ins>If _found_ is *false*, then</ins>
              1. Append <del>_name_</del><ins>_mr_</ins> to <del>_moduleNames_</del><ins>_requests_</ins>.
          1. Return <del>_moduleNames_</del><ins>_requests_</ins>.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>
          ImportDeclaration : `import` ImportClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~evaluation~ }.</ins>
        </emu-alg>
        <emu-grammar><ins>ImportDeclaration : `import` `source` ImportedBinding FromClause `;`</ins></emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~source~ }.</ins>
        </emu-alg>
        <emu-grammar><del>ModuleSpecifier : StringLiteral</del></emu-grammar>
        <emu-alg>
          1. <del>Return a List whose sole element is the SV of |StringLiteral|.</del>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be SV of |FromClause|.</ins>
          1. <ins>Return a List whose sole element is the ModuleRequest Record { [[Specifer]]: _specifier_, [[Phase]]: ~evaluation~ }.</ins>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>
        <p>A <dfn variants="Module Records">Module Record</dfn> encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.</p>
        <p>For specification purposes Module Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named Cyclic Module Record and its concrete subclass named Source Text Module Record. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.</p>
        <p>Module Record defines the fields listed in <emu-xref href="#table-module-record-fields"></emu-xref>. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>. All Module definition subclasses must provide concrete implementations of these abstract methods.</p>
        <emu-table id="table-module-record-fields" caption="Module Record Fields" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                a Realm Record
              </td>
              <td>
                The Realm within which this module was created.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                a Module Environment Record or ~empty~
              </td>
              <td>
                The Environment Record containing the top level bindings for this module. This field is set when the module is linked.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                an Object or ~empty~
              </td>
              <td>
                The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>) if one has been created for this module.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is *undefined*)
              </td>
              <td>
                Field reserved for use by host environments that need to associate additional information with a module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="Abstract Methods of Module Records" oldids="table-37">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                LoadRequestedModules( [ _hostDefined_ ] )
              </td>
              <td>
                <p>Prepares the module for linking by recursively loading all its dependencies, and returns a promise.</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>Return a list of all names that are either directly or indirectly exported from this module.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>Return the binding of a name exported by this module. Bindings are represented by a <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn>, of the form { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ }. If the export is a Module Namespace Object without a direct binding in any module, [[BindingName]] will be set to ~namespace~. Return *null* if the name cannot be resolved, or ~ambiguous~ if multiple bindings were found.</p>
                <p>Each time this operation is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>Prepare the module for evaluation by transitively resolving all module dependencies and creating a Module Environment Record.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>Returns a promise for the evaluation of this module and its dependencies, resolving on successful evaluation or if it has already been evaluated successfully, and rejecting for an evaluation error or if it has already been evaluated unsuccessfully. If the promise is rejected, hosts are expected to handle the promise rejection and rethrow the evaluation error.</p>
                <p>Link must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                <ins>GetModuleSource()</ins>
              </td>
              <td>
                <p><ins>It returns either a normal completion containing the Module Source Object corresponding to this source Module Record's source phase (<emu-xref href="#sec-module-source-objects"></emu-xref>), or a throw completion.</ins></p>
                <p><ins>When called multiple times on the same Module Record, if GetModuleSource() returns a normal completion it must always return a normal completion containing the same object.</ins></p>
                <p><ins>The returned object should have a [[Prototype]] internal slot whose value is %AbstractModuleSource.prototype%.</ins></p>
                <p><ins>For Module Records that do not have a source representation, GetModuleSource() must always return a throw completion whose [[Value]] is a *ReferenceError*.</ins></p>
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>

        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~unlinked~. Transitions to ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this non-negative number records the point at which the module was first visited during the depth-first traversal of the dependency graph.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of <del>Strings</del><ins>ModuleRequest Records</ins>
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module, <ins>along with their associated phase (~source~ or ~evaluation~)</ins>. The List is in source text occurrence order.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is equal to the [[DFSIndex]] of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is either itself asynchronous or has an asynchronous dependency. Note: The order in which this field is set is used to order queued executions, see <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything,
            ): a Promise object
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>
            <dt>description</dt>
            <dd>It populates the [[LoadedModules]] of all the Module Records in the dependency graph of _module_ (most of the work is done by the auxiliary function InnerModuleLoading). It takes an optional _hostDefined_ parameter that is passed to the HostLoadImportedModule hook.</dd>
          </dl>
          <emu-alg>
            1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Let _state_ be the GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: ¬´ ¬ª, [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.
            1. Perform InnerModuleLoading(_state_, _module_<ins>, ~recursive-load~</ins>).
            1. Return _pc_.[[Promise]].
          </emu-alg>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>_loadType_: ~single~ or ~recursive-load~,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. If <ins>_loadType_ is ~recursive-load~, </ins>_module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. <del>For each String _required_ of _module_.[[RequestedModules]], do</del>
                1. <ins>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</ins>
                  1. If _module_.[[LoadedModules]] contains a Record whose [[Specifier]] is _required_<ins>.[[Specifier]]</ins>, then
                    1. Let _record_ be that Record.
                    1. <ins>If _required_.[[Phase]] is ~source~, let _innerLoadType_ be ~single~; otherwise let _innerLoadType_ be ~recursive-load~.</ins>
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], <ins>_innerLoadType_</ins>).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, _required_, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] ‚â• 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, ¬´ *undefined* ¬ª).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a GraphLoadingState Record,
                <ins>_phase_: ~source~ or ~evaluation~,</ins>
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. If _moduleCompletion_ is a normal completion, then
                1. <ins>If _phase_ is ~source~, let _loadType_ be ~single~; otherwise let _loadType_ be ~recursive-load~.</ins>
                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]<ins>, _loadType_</ins>).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, ¬´ _moduleCompletion_.[[Value]] ¬ª).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
          <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>On success, Link transitions this module's [[Status]] from ~unlinked~ to ~linked~. On failure, an exception is thrown and this module's [[Status]] remains ~unlinked~. (Most of the work is done by the auxiliary function InnerModuleLinking.)</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
            <h1>
              InnerModuleLinking (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Link().
                1. Return _index_.
              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Set _module_.[[Status]] to ~linking~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. For each <del>String</del><ins>ModuleRequest Record</ins> _required_ of _module_.[[RequestedModules]], do
                1. <ins>If _required_.[[Phase]] is ~evaluation~, then</ins>
                  1. Let _requiredModule_ be GetImportedModule(_module_, _required_<ins>.[[Specifier]]</ins>).
                  1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~linking~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ‚â§ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to ~linked~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
        <emu-clause id="sec-moduleevaluation" type="concrete method">
          <h1>Evaluate ( ): a Promise</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>Evaluate transitions this module's [[Status]] from ~linked~ to either ~evaluating-async~ or ~evaluated~. The first time it is called on a module in a given strongly connected component, Evaluate creates and returns a Promise which resolves when the module has finished evaluating. This Promise is stored in the [[TopLevelCapability]] field of the [[CycleRoot]] for the component. Future invocations of Evaluate on any module in the component return the same Promise. (Most of the work is done by the auxiliary function InnerModuleEvaluation.)</dd>
          </dl>

          <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
            <h1>
              InnerModuleEvaluation (
                _module_: a Module Record,
                _stack_: a List of Cyclic Module Records,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in InnerModuleLinking.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Let _promise_ be ! _module_.Evaluate().
                1. Assert: _promise_.[[PromiseState]] is not ~pending~.
                1. If _promise_.[[PromiseState]] is ~rejected~, then
                  1. Return ThrowCompletion(_promise_.[[PromiseResult]]).
                1. Return _index_.
              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then
                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                1. Otherwise, return ? _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is ~evaluating~, return _index_.
              1. Assert: _module_.[[Status]] is ~linked~.
              1. Set _module_.[[Status]] to ~evaluating~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _module_.[[PendingAsyncDependencies]] to 0.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. <del>For each String _required_ of _module_.[[RequestedModules]], do</del>
              1. <ins>For each ModuleRequest Record _required_ of _module_.[[RequestedModules]], do</ins>
                1. Let _requiredModule_ be GetImportedModule(_module_, _required_<ins>.[[Specifier]]</ins>).
                1. <ins>If _requiredModule_.[[Phase]] is ~evaluation~, then</ins>
                  1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~evaluating~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                    1. Else,
                      1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                      1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                      1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                    1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then
                      1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.
                      1. Append _module_ to _requiredModule_.[[AsyncParentModules]].
              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then
                1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.
                1. Set _module_.[[AsyncEvaluation]] to *true*.
                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.)
                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).
              1. Else,
                1. Perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] ‚â§ _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element of _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.
                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                  1. Set _requiredModule_.[[CycleRoot]] to _module_.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <emu-clause id="sec-source-text-module-record-getmodulesource" type="concrete method">
          <h1>
            <ins>
              GetModuleSource ( ): either a normal completion containing an Object or a throw completion
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>

            <dt>description</dt>
            <dd>
              <p>Source Text Module Record provides a GetModuleSource implementation that always returns an abrupt completion indicating that a source phase import is not available.</p>
            </dd>
          </dl>
          <emu-alg>
            1. Throw a *ReferenceError* exception.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. <ins>Else if _in_.[[ImportName]] is ~source~, then</ins>
                1. <ins>Let _moduleSourceObject_ be ? _importedModule_.GetModuleSource().</ins>
                1. <ins>Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).</ins>
                1. <ins>Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _moduleSourceObject_).</ins>
              1. Else,
                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _declaredVarNames_ does not contain _dn_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>
      <p>An <dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-importentry-record-fields"></emu-xref>:</p>
      <emu-table id="table-importentry-record-fields" caption="ImportEntry Record Fields" oldids="table-39">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[ModuleRequest]]
            </td>
            <td>
              a String
            </td>
            <td>
              String value of the |ModuleSpecifier| of the |ImportDeclaration|.
            </td>
          </tr>
          <tr>
            <td>
              [[ImportName]]
            </td>
            <td>
              a String <del>or ~namespace-object~</del><ins>, ~namespace-object~ or ~source~</ins>
            </td>
            <td>
              The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. The value ~namespace-object~ indicates that the import request is for the target module's namespace object. <ins>The value ~source~ represents an import at the source phase.</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[LocalName]]
            </td>
            <td>
              a String
            </td>
            <td>
              The name that is used to locally access the imported value from within the importing module.
            </td>
          </tr>
        </table>
      </emu-table>
      <emu-note class="module-overflow-note">
        <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> gives examples of ImportEntry records fields used to represent the syntactic import forms:</p>
        <emu-table id="table-import-forms-mapping-to-importentry-records" caption="Import Forms Mappings to ImportEntry Records" informative oldids="table-40">
          <table>
            <tr>
              <th>
                Import Statement Form
              </th>
              <th>
                [[ModuleRequest]]
              </th>
              <th>
                [[ImportName]]
              </th>
              <th>
                [[LocalName]]
              </th>
            </tr>
            <tr>
              <td>
                `import v from "mod";`
              </td>
              <td>
                *"mod"*
              </td>
              <td>
                *"default"*
              </td>
              <td>
                *"v"*
              </td>
            </tr>
            <tr>
              <td>
                `import * as ns from "mod";`
              </td>
              <td>
                *"mod"*
              </td>
              <td>
                ~namespace-object~
              </td>
              <td>
                *"ns"*
              </td>
            </tr>
            <tr>
              <td>
                `import {x} from "mod";`
              </td>
              <td>
                *"mod"*
              </td>
              <td>
                *"x"*
              </td>
              <td>
                *"x"*
              </td>
            </tr>
            <tr>
              <td>
                `import {x as v} from "mod";`
              </td>
              <td>
                *"mod"*
              </td>
              <td>
                *"x"*
              </td>
              <td>
                *"v"*
              </td>
            </tr>
            <tr>
              <td>
                `import "mod";`
              </td>
              <td colspan="3">
                An ImportEntry Record is not created.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-note>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation">
        <h1>
          HostLoadImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            <del>_specifier_: a String,</del>
            <ins>_moduleRequest_: a ModuleRequest Record,</ins>
            _hostDefined_: anything,
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>An example of when _referrer_ can be a Realm Record is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The host environment must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
          </li>
          <li>
            If this operation is called multiple times with the same (_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>) pair and it performs FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_) where _result_ is a normal completion, then it must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_) with the same _result_ each time.
          </li>
          <li>
            <ins>The completion record returned by this operation must not be affected by _moduleRequest_.[[Phase]].</ins>
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadingImportedModule.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to load the appropriate Module Record. Multiple different (_referrer_, <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>) pairs may map to the same Module Record instance. The actual mapping semantics is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as expansion of relative and abbreviated path specifiers.</p>

        <emu-note>
          <p><ins><emu-xref href="#sec-hosts-and-implementations">Implementations</emu-xref> may provide unobservable module loading optimizations, such as speculative preloading of modules that are likely to be requested next. When doing so, they should consider whether the module is being imported for its ~source~ phase, which won't cause calls to the HostLoadImportedModule hook for its transitive dependencies, or for its ~evaluation~ phase, which will.</ins></p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            <del>_specifier_: a String,</del>
            <ins>_moduleRequest_: a ModuleRequest Record,</ins>
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record whose [[Specifier]] is <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: <del>_specifier_</del><ins>_moduleRequest_.[[Specifier]]</ins>, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _payload_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_payload_, <ins>_moduleRequest_.[[Phase]],</ins> _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, <ins>_moduleRequest_.[[Phase]],</ins> _result_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostGetModuleSourceName" type="host-defined abstract operation">
        <h1>
          <ins>
            HostGetModuleSourceName (
              _moduleSource_: an Object,
            ): either a normal completion containing a String or a throw completion
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <p>An implementation of HostGetModuleSourceName must conform to the following requirements:</p>
        <ul>
          <li>
            For any object that is a Module Source Object, returns a normal completion for a String corresponding to the source record type to be used as the strongly branded return value of the @@toStringTag getter on %AbstractModuleSource%.
          </li>
          <li>
            For any object which is not a Module Source Object, returns a throw completion.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-imports">
    <h1>Imports</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ImportDeclaration :
        `import` ImportClause FromClause `;`
        `import` ModuleSpecifier `;`
        <ins>`import` `source` ImportedBinding FromClause `;`</ins>

      ImportClause :
        ImportedDefaultBinding
        NameSpaceImport
        NamedImports
        ImportedDefaultBinding `,` NameSpaceImport
        ImportedDefaultBinding `,` NamedImports
  
      ImportedDefaultBinding :
        ImportedBinding
  
      NameSpaceImport :
        `*` `as` ImportedBinding
  
      NamedImports :
        `{` `}`
        `{` ImportsList `}`
        `{` ImportsList `,` `}`
  
      FromClause :
        `from` ModuleSpecifier
  
      ImportsList :
        ImportSpecifier
        ImportsList `,` ImportSpecifier
  
      ImportSpecifier :
        ImportedBinding
        ModuleExportName `as` ImportedBinding
  
      ModuleSpecifier :
        StringLiteral
  
      ImportedBinding :
        BindingIdentifier[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="syntax-directed operation">
      <h1>Static Semantics: ImportEntries ( ): a List of ImportEntry Records</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ImportEntries of |ModuleItemList|.
        1. Let _entries2_ be ImportEntries of |ModuleItem|.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ExportDeclaration
          StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Let _module_ be the <del>sole element of ModuleRequests</del><ins>SV</ins> of |FromClause|.
        1. Return ImportEntriesForModule of |ImportClause| with argument _module_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar><ins>ImportDeclaration : `import` `source` ImportedBinding FromClause `;`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _module_ be the SV of |FromClause|.</ins>
        1. <ins>Let _localName_ be the sole element of BoundNames of |ImportedBinding|.</ins>
        1. <ins>Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~source~, [[LocalName]]: _localName_ }.</ins>
        1. <ins>Return ¬´ _entry_ ¬ª</ins>.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection" number="28">
  <h1>Reflection</h1>
  <emu-clause id="sec-module-source-objects">
    <h1><ins>Module Source Objects</ins></h1>
    <p>Module Source Objects represent modules in their source import phase, which are not linked, instantiated or executed.</p>
    <p>A <dfn>Module Source Object</dfn> is an object for which HostGetModuleSourceName returns a normal completion.</p>
    <p>All Module Source Objects should have a prototype of %AbstractModuleSource%.prototype.</p>
    <p>Hosts may define their own %AbstractModuleSource% subclasses for custom module types.</p>

    <emu-clause id="sec-%abstractmodulesource%-constructor">
      <h1>The %AbstractModuleSource% Constructor</h1>
      <p>The %AbstractModuleSource% constructor:</p>
      <ul>
        <li>along with its corresponding prototype object, provides common properties that are inherited by Module Source constructors and their instances.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>acts as a common superclass of the constructors of Module Source Objects.</li>
        <li>will throw an error when invoked, because it is an abstract class constructor. The module source constructors do not perform a `super` call to it.</li>
      </ul>

      <emu-clause id="sec-%abstractmodulesource%">
        <h1>%AbstractModuleSource% ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%abstractmodulesource%-intrinsic-object">
      <h1>Properties of the %AbstractModuleSource% Intrinsic Object</h1>
      <p>The %AbstractModuleSource% intrinsic object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"name"* property whose value is *"AbstractModuleSource"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%abstractmodulesource%.prototype">
        <h1>%AbstractModuleSource%.prototype</h1>
        <p>The initial value of %AbstractModuleSource%`.prototype` is the %AbstractModuleSource% prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%abstractmodulesource%-prototype-object">
      <h1>Properties of the %AbstractModuleSource% Prototype Object</h1>
      <p>The <dfn>%AbstractModuleSource% prototype object</dfn>:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is <dfn>%AbstractModuleSource.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%abstractmodulesource%.prototype.constructor">
        <h1>%AbstractModuleSource%.prototype.constructor</h1>
        <p>The initial value of %AbstractModuleSource%`.prototype.constructor` is %AbstractModuleSource%.</p>
      </emu-clause>

      <emu-clause id="sec-get-%abstractmodulesource%.prototype.@@tostringtag">
        <h1>get %AbstractModuleSource%.prototype [ @@toStringTag ]</h1>
        <p>%AbstractModuleSource%.prototype `[@@toStringTag]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, return *undefined*.
          1. Let _sourceNameResult_ be Completion(HostGetModuleSourceName(_O_)).
          1. If _sourceNameResult_ is an abrupt completion, return *undefined*.
          1. Let _name_ be ! _sourceNameResult_.
          1. Assert: _name_ is a String.
          1. Return _name_.
        </emu-alg>
        <p>This property has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The initial value of the *"name"* property of this function is *"get [Symbol.toStringTag]"*.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>

  <emu-annex id="sec-host-hooks-summary">
    <h1>Host Hooks</h1>
    <p><b>HostCallJobCallback(...)</b></p>
    <p><b>HostEnqueueFinalizationRegistryCleanupJob(...)</b></p>
    <p><b>HostEnqueueGenericJob(...)</b></p>
    <p><b>HostEnqueuePromiseJob(...)</b></p>
    <p><b>HostEnqueueTimeoutJob(...)</b></p>
    <p><b>HostEnsureCanCompileStrings(...)</b></p>
    <p><b>HostFinalizeImportMeta(...)</b></p>
    <p><b>HostGetImportMetaProperties(...)</b></p>
    <p><b><ins>HostGetModuleSourceName(...)</ins></b></p>
    <p><b>HostGrowSharedArrayBuffer(...)</b></p>
    <p><b>HostHasSourceTextAvailable(...)</b></p>
    <p><b>HostLoadImportedModule(...)</b></p>
    <p><b>HostMakeJobCallback(...)</b></p>
    <p><b>HostPromiseRejectionTracker(...)</b></p>
    <p><b>HostResizeArrayBuffer(...)</b></p>
    <p><b>InitializeHostDefinedRealm(...)</b></p>
  </emu-annex>
</emu-annex>
